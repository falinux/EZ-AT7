//------------------------------------------------------------------------------
// 화일명 : irq.c
// 설  명 : ezload의 irq 처리와 관련된 루틴이다. 
// 
// 작성자 : 유영창 
// 작성일 : 2007년 5월 26일
// 저작권 : 
// 주  의 : 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
// 헤더 정의
//
//------------------------------------------------------------------------------
#include <typedef.h>
#include <register.h>
#include <setup.h>

#include <console.h>
//#include <usb_console.h>
#include <irq.h>
#include <stdio.h>
#include <string.h>

#define IRQ_MASK		0x00000080

//------------------------------------------------------------------------------
//
// 광역 변수 정의
//
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// 설명 : 인터럽트 핸들러가 등록되지 않았을때의 빈 처리 핸들러
//------------------------------------------------------------------------------
RAMFUNC static void irq_none( void )
{
	
}

//------------------------------------------------------------------------------
// 설명 : CPSR 값을 얻는다.
//------------------------------------------------------------------------------
RAMFUNC static inline u32 __get_cpsr(void)
{
	u32 state;
	asm volatile (" mrs  %0, cpsr" : "=r" (state) : /* no inputs */  );
	return state;
}

//------------------------------------------------------------------------------
// 설명 : CPSR 값을 설정한다.
//------------------------------------------------------------------------------
RAMFUNC static inline void __set_cpsr( u32 state )
{
	asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (state)  );
}

//------------------------------------------------------------------------------
// 설명 : IRQ 인터럽트를 금지한다. 
//------------------------------------------------------------------------------
RAMFUNC u32 irq_disable(void)
{
	u32 _cpsr;

	_cpsr = __get_cpsr();
	__set_cpsr(_cpsr | IRQ_MASK);
	return _cpsr;
}


//------------------------------------------------------------------------------
// 설명 : 이전 IRQ 인터럽트를 상태로 만든다. 
//------------------------------------------------------------------------------
RAMFUNC u32 irq_restore( u32 oldCPSR )
{
	u32 _cpsr;

	_cpsr = __get_cpsr();
	__set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
	return _cpsr;
}

//------------------------------------------------------------------------------
// 설명 : IRQ 인터럽트를 허가 한다. 
//------------------------------------------------------------------------------
RAMFUNC u32 irq_enable(void)
{
	u32 _cpsr;

	_cpsr = __get_cpsr();
	__set_cpsr(_cpsr & ~IRQ_MASK);
	return _cpsr;
}

//------------------------------------------------------------------------------
// 설명 : IRQ 핸들러를 등록한다.
// 주의 : 등록되는 IRQ 는 모두 동일한 우선권을 갖는다. 
//------------------------------------------------------------------------------
void irq_request ( u32 irq, u32 type, void (*irq_func ) (void ) )
{
	volatile u32 *AIC_SVRs;
	volatile u32 *AIC_SMRs;
    u32 		  mask;

	AIC_SVRs = &(AIC_SVR);
	AIC_SMRs = &(AIC_SMR);
	
    mask = 0x1 << irq ;

    AIC_IDCR = mask ;							// 인터럽트 금지 
    AIC_SVRs[irq] = (u32) irq_func ;				// 인터럽트 서비스 루틴 등록
    AIC_SMRs[irq] = type | AIC_PRIOR_HIGHEST;		// 우선 순위와 인터럽트 타입

    AIC_ICCR = mask ;							// 인터럽트 펜딩상태 클리어 
}

//------------------------------------------------------------------------------
// 설명 : IRQ 핸들러를 삭제 한다. 
//------------------------------------------------------------------------------
void irq_free( u32 irq )
{
	volatile u32 *AIC_SVRs;
    u32 		  mask;

	AIC_SVRs = &(AIC_SVR);
    mask = 0x1 << irq ;

    AIC_IDCR = mask ;							// 인터럽트 금지 
    AIC_SVRs[irq] = (u32) irq_none ;				// 인터럽트 서비스 루틴 등록
    AIC_ICCR = mask ;							// 인터럽트 펜딩상태 클리어 
}

//------------------------------------------------------------------------------
// 설명 : IRQ 인터럽트 번호 활성화 
//------------------------------------------------------------------------------
void RAMFUNC irq_active( u32 irq )
{
    AIC_IECR = 0x1 << irq;
}
//------------------------------------------------------------------------------
// 설명 : IRQ 인터럽트 번호 비 활성화
//------------------------------------------------------------------------------
void RAMFUNC irq_deactive( u32 irq )
{
    u32 mask;
    
    mask = 0x1 << irq;
    
    AIC_IDCR = mask ;
    AIC_ICCR = mask ;
}

//*----------------------------------------------------------------------------
// 설명 : IRQ 인터럽트 상태 클리어
//*----------------------------------------------------------------------------
void RAMFUNC irq_clear( u32 irq )
{
    AIC_ICCR = (0x1 << irq);
}

//------------------------------------------------------------------------------
// 설명 : IRQ 처리를 초기화 한다.
//------------------------------------------------------------------------------
void irq_init( void )
{
	volatile u32 *AIC_SVRs;
	
	u32 lp;
	
	AIC_SVRs = &(AIC_SVR);
	
	// 아무것도 처리하지 않는 인터럽트 핸들러 함수를 IRQ 인터럽트 핸들러에 등록한다. 
	for(lp=1; lp<31; lp++)
	{
		if(lp!=2)AIC_SVRs[lp] = (u32) irq_none;	//system irq는 그대로 사용한다.
	}
	AIC_SPU = (u32) irq_none;
	
	irq_enable();
}

